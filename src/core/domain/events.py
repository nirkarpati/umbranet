"""Event models for the Governor system.

These models define the data structures for input events and output responses
that flow through the Governor system from various channels (Telegram, WhatsApp, etc).
"""

from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field, validator


class ChannelType(str, Enum):
    """Supported communication channels."""
    
    TELEGRAM = "telegram"
    WHATSAPP = "whatsapp"
    VOICE = "voice"
    SMS = "sms"
    EMAIL = "email"
    WEB = "web"
    API = "api"
    DIRECT = "direct"
    WEBHOOK = "webhook"


class MessageType(str, Enum):
    """Types of messages that can be processed."""
    
    TEXT = "text"
    VOICE = "voice"
    IMAGE = "image"
    DOCUMENT = "document"
    LOCATION = "location"
    COMMAND = "command"
    SYSTEM = "system"


class ResponseType(str, Enum):
    """Types of responses the Governor can generate."""
    
    TEXT = "text"
    VOICE = "voice"
    IMAGE = "image"
    FILE = "file"
    STRUCTURED = "structured"
    CONFIRMATION_REQUEST = "confirmation_request"
    ERROR = "error"


class GovernorEvent(BaseModel):
    """Normalized input event from any communication channel.
    
    This is the standard format that all incoming messages are converted to,
    regardless of their original channel (Telegram, WhatsApp, Voice, etc).
    """
    
    user_id: str = Field(
        ...,
        description="Unique identifier for the user",
        min_length=1,
        max_length=100
    )
    
    session_id: str = Field(
        ...,
        description="Unique identifier for this conversation session",
        min_length=1,
        max_length=100
    )
    
    message_type: MessageType = Field(
        ...,
        description="Type of the incoming message"
    )
    
    content: str = Field(
        ...,
        description="The actual message content (text, transcribed voice, etc)",
        min_length=1,
        max_length=10000
    )
    
    channel: ChannelType = Field(
        ...,
        description="The communication channel this message came from"
    )
    
    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this event was created (UTC)"
    )
    
    metadata: dict[str, Any] = Field(
        default_factory=dict,
        description="Channel-specific metadata (message IDs, user info, etc)"
    )
    
    raw_payload: dict[str, Any] | None = Field(
        None,
        description="Original raw payload for debugging/logging"
    )
    
    @validator('user_id', 'session_id')
    def validate_ids(cls, v: str) -> str:
        """Ensure IDs don't contain special characters."""
        if not v.replace('_', '').replace('-', '').isalnum():
            raise ValueError(
                "IDs must be alphanumeric with optional hyphens/underscores"
            )
        return v
    
    @validator('content')
    def validate_content(cls, v: str) -> str:
        """Ensure content is not empty after stripping."""
        if not v.strip():
            raise ValueError("Content cannot be empty")
        return v.strip()
    
    class Config:
        """Pydantic configuration."""
        json_encoders = {
            datetime: lambda dt: dt.isoformat()
        }
        json_schema_extra = {
            "example": {
                "user_id": "user_123",
                "session_id": "telegram_user_123_20241127",
                "message_type": "text",
                "content": "What's the weather like today?",
                "channel": "telegram",
                "timestamp": "2024-11-27T18:30:00Z",
                "metadata": {
                    "telegram_message_id": 12345,
                    "telegram_chat_id": -987654321
                }
            }
        }


class GovernorResponse(BaseModel):
    """Structured output response to be sent back to the user.
    
    This is the standard format for all responses generated by the Governor,
    which are then adapted to the specific channel format before delivery.
    """
    
    user_id: str = Field(
        ...,
        description="User this response is intended for"
    )
    
    session_id: str = Field(
        ...,
        description="Session this response belongs to"
    )
    
    content: str = Field(
        ...,
        description="The response content to send to the user",
        min_length=1,
        max_length=10000
    )
    
    response_type: ResponseType = Field(
        default=ResponseType.TEXT,
        description="Type of response being sent"
    )
    
    channel: ChannelType = Field(
        ...,
        description="Channel to send this response through"
    )
    
    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this response was generated (UTC)"
    )
    
    metadata: dict[str, Any] = Field(
        default_factory=dict,
        description="Response-specific metadata (formatting, attachments, etc)"
    )
    
    requires_confirmation: bool = Field(
        default=False,
        description="Whether this response requires user confirmation before proceeding"
    )
    
    confirmation_context: dict[str, Any] | None = Field(
        None,
        description="Context data for confirmation flow if required"
    )
    
    urgency_level: str = Field(
        default="normal",
        description="Priority level: low, normal, high, urgent"
    )
    
    @validator('urgency_level')
    def validate_urgency(cls, v: str) -> str:
        """Validate urgency level."""
        valid_levels = {"low", "normal", "high", "urgent"}
        if v not in valid_levels:
            raise ValueError(f"Urgency level must be one of: {valid_levels}")
        return v
    
    class Config:
        """Pydantic configuration."""
        json_encoders = {
            datetime: lambda dt: dt.isoformat()
        }
        json_schema_extra = {
            "example": {
                "user_id": "user_123",
                "session_id": "telegram_user_123_20241127",
                "content": (
                    "The current weather in Seattle is sunny "
                    "with a temperature of 72Â°F."
                ),
                "response_type": "text",
                "channel": "telegram",
                "timestamp": "2024-11-27T18:30:15Z",
                "metadata": {
                    "parse_mode": "markdown",
                    "disable_web_page_preview": True
                },
                "requires_confirmation": False,
                "urgency_level": "normal"
            }
        }


class EventMetadata(BaseModel):
    """Helper model for common event metadata patterns."""
    
    source_ip: str | None = None
    user_agent: str | None = None
    request_id: str | None = None
    processing_time_ms: float | None = None
    retry_count: int | None = 0
    error_count: int | None = 0


class ResponseMetadata(BaseModel):
    """Helper model for common response metadata patterns."""
    
    delivery_method: str | None = None
    delivery_status: str | None = None
    delivery_timestamp: datetime | None = None
    retry_attempts: int | None = 0
    format_version: str = "v1"